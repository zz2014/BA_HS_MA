% Die Arbeit besteht aus Kapiteln (chapter)
\chapter{Technological Background}
\label{technological background}
Performance and load testing has been conducted ever since applications came into been. There is a sea of different tools that can fulfill the task of generating virtual end users. In the case of this paper, the server's capacity is going to be driven to its limit, after which instead of staying overloaded, the server will try to scale and consume more clients. This requires the testing tool to be capable of generating a large enough amount of end users. \\
One of the most popular testing tools is JMeter which is based on Java and cross-platform. It supports multiple protocol and has a very friendly UI to configure test plans. It even produces aggregated test results in different type of graphs. It seems it has everything one asks for except scalibility. When the test requires a bigger scale, JMeter client machine quickly runs into issue that it is unable, performance-wise, to simulate enough users to stress the server or is limited at network level. An option to work around this performance limitation is to utilize remote/distributed testing \index{Cite}\footnote{JMeter Remote Testing \cite{JMeterRemote}}to control multiple remote JMeter engines from a single JMeter client. In this way, one can replicate a test across many low-end computers and thus simulate a larger load on the server. However, remote mode does use more resources than running the same number of non-GUI tests independently. If many server instances are used, the client JMeter can become overloaded, as can the client network connection. Another inconvenience of using JMeter is to find a ideal environment to host it. While one can execute the JMeterEngine on the application server, one can not ignore the fact that this will be adding processing overhead on the application server, consequently  the testing results will be somewhat tainted. All put together, it is decided not to use JMeter as load generating and testing tool in the project. \\
nGrinder is a platform for stress tests that enables you to execute script creation, test execution, monitoring, and result report generator simultaneously \index{Cite}\footnote{nGrinder Github \cite{NGrinder}}. nGrinder consists of two major components. One is  controller, a web application that enables the performance tester to create a test script and configure a test run. One is agent, a virtual user generator that creates loads. 
The performance team of Cloud Foundry in SAP has conducted their load test on router with nGrinder. The controller operates in a dedicated AWS c3.xlarge instance with 4 CPUs and 7.5 GB memory. Four agents are installed to create loads. Two of those agents are running on the host machine with controller and two others are distributed to another AWS c3.xlarge virtual machine. It manages to produce a load of 8500 requests per second to be handled by a router instance with 16 CPUs and 30 GB memory. nGrinder is considered too resource consuming and therefore not applied in this project. Other comparatively more light-weight test frameworks like Locust are shortly considered but not decided for this project due to the complexity to scale the client.\\
The Cloud Foundry Routing team has approached the load generating in a way similar to this project. They used a simple utility called \textit{hey} \index{Cite}\footnote{hey Github \cite{Hey}}. The tool is written in Go which accomplishes two tasks: generate a given number of requests and aggregate a simple report at the end of the test. It occupies next to nothing of the memory (less than 10m) and is intended to quickly smoke-test a web-application. Thus it is not a complex tool which can define a desired user behavior. It is actually quite fit for the use case of this project except that the original implementation of the tool persist no test results in database which also facilitates its lightweight. To enhance the tool with desired database connection would be too time consuming because the existence of this tool comes into knowledge at a late state of project. At this point of time, another similar functioning tool in node is already maturely implemented and in use.\\    




  
